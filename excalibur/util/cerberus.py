'''utilites used by many tasks'''

# Heritage code shame:
# pylint: disable=invalid-name
# pylint: disable=too-many-locals,too-many-statements,too-many-arguments,too-many-positional-arguments

from __future__ import annotations

# -- IMPORTS -- ------------------------------------------------------
import numpy as np
import matplotlib.pyplot as plt


def calcTEA(
    tp_coeffs,
    pressure,
    species,
    metallicity=1.0,
    C_O=None,
    N_O=None,
    plot_tp=False,
    abundance_file="abundances.txt",
    cfg_file="TEA.cfg",
    stoich_file="stoich.txt",
):
    """
    Parameters
    ----------
    tp_coeffs : 1-D array of 10 values. See _make_tp_profile for what each value does. Best to only fit/retrieve one or two tp values and leave the rest constant.
    pressure       : pressure grid
    species            : array of desired species ["H2O_g", "CH4_g", ...]. Must use format seen here to work with TEA. Must use the filename for the species in    /gdata. Sometimes the extension will be like _ref. For example "N2_ref".

    metallicity        : X solar
    C_O              : None = solar. Also 0.55 = solar. This is the number ratio so 1.1 is 2x solar metallicity.
    N_O              : Same as C_O
    plot_tp          : If set to True plots the TP profile generated by tp_coeffs
    abundance_file   : Path to abundance file
    cfg_file         : Path to .cfg file. This is the only file you might have to change. If iteration isn't converging you can increase max_iter. Also, if species being input is creating problems it may have to be added into this file. The file already holds the main absorbers used in exoplanet science but if you want to use some weird ones you'll have to update this. Make sure when you add an output species that the input elems also include all of the elements in the output molecule (species). Must all be in TEA format in accordance with /gdata files.

    Returns
    -------
    mixratio as dict like {'H2O': 0.01, ...} in format used by crbfm. Mixing ratios used are the average value across the pressure grid.
    """
    from excalibur.cerberus.tea_code import python_makeatm as ma
    from excalibur.cerberus.tea_code import python_runatm as ra

    input_species = species

    def _make_tp_profile(
        P,
        shift,  # log-P shift (moves inversion up/down)
        T_base=1500,  # background scale
        alpha=0.05,  # background slope
        P_ref=1e-2,  # ref pressure
        a_rise=400,  # rise amplitude
        c_rise=-2.3,  # center of rise (in log10 P)
        w_rise=0.25,  # width of rise
        a_fall=-350,  # fall amplitude
        c_fall=-1.9,  # center of fall
        w_fall=0.35,
    ):  # width of fall

        x = np.log10(P) + shift
        T_bg = T_base * (P / P_ref) ** alpha

        rise = a_rise * np.tanh((x - c_rise) / w_rise)
        fall = a_fall * np.tanh((x - c_fall) / w_fall)

        inv_rise = a_rise * (
            np.tanh((x - c_rise) / w_rise) - np.tanh(-(c_rise) / w_rise)
        )
        inv_fall = a_fall * (
            np.tanh((x - c_fall) / w_fall) - np.tanh(-(c_fall) / w_fall)
        )

        T = T_bg + inv_rise + inv_fall
        return T

    def _reservoir_base(el: str, gdir: Path) -> str:
        """
        Return base name for atomic reservoir species for element `el`
        (e.g. 'He_ref', 'O_g').  Searches for
            {el}_g.{dat/txt}   then   {el}_ref.{dat/txt}   then   {el}2_ref.{dat/txt}
        Raises FileNotFoundError if none are found.
        """
        candidates = [f"{el}_g", f"{el}_ref", f"{el}2_ref"]
        for base in candidates:
            for ext in (".dat", ".txt"):
                if (gdir / f"{base}{ext}").exists():
                    return base
        raise FileNotFoundError(f"No thermo file for element '{el}' in {gdir}")

    def _read_solar_abund(abundance_file: str) -> dict[str, float]:
        """
        Returns dict {element_symbol: number_fraction} with H fixed at 1.0.

        The Asplund table gives log₁₀(N_X) on a scale where log₁₀(N_H)=12.00.
        We therefore convert with:
         N_X / N_H = 10**(dex_X - 12)
        so H=1.0, He≈0.085, C≈2.7e-4, N≈6.8e-5, O≈4.9e-4, … (solar values).
        """
        data = np.genfromtxt(abundance_file, comments="#", dtype=str)
        symbols = data[:, 1]
        dex = data[:, 2].astype(float)

        num_dens = 10.0 ** (dex - 12.0)
        return {sym: val for sym, val in zip(symbols, num_dens)}

    # scale abundances for metallicity, C/O, N/O
    def _scale_abund(
        solar: dict[str, float],
        metallicity: float,
        C_O: float | None,
        N_O: float | None,
    ) -> dict[str, float]:
        """
        Apply metallicity & C/O, N/O tweaks while preserving mass balance.
        H & He are rescaled together (constant H/He ratio).
        """
        abund = solar.copy()

        metals = [el for el in abund if el not in ("H", "He")]
        for el in metals:
            abund[el] *= metallicity

        if C_O is not None:
            O = abund["O"]
            abund["C"] = C_O * O

        if N_O is not None:
            O = abund["O"]
            abund["N"] = N_O * O

        return abund

    pressure = np.asarray(pressure, dtype=float)
    temperature = _make_tp_profile(pressure, *tp_coeffs)
    if plot_tp == True:
        plt.plot(temperature, pressure)
        plt.yscale("log")
        plt.gca().invert_yaxis()
        plt.title("Temperature Pressure Profile")

    solar = _read_solar_abund(abundance_file)

    from excalibur.cerberus.tea_code import makeheader as mh

    _, elem_arr = mh.read_stoich(species, stoich_file=stoich_file)

    needed_elem = set(elem_arr) | {"H"}

    from pathlib import Path

    gdir = Path(cfg_file).with_name("gdata")
    atomic = [_reservoir_base(el, gdir) for el in needed_elem]

    species_ordered = []
    for sp in atomic:
        if sp not in species_ordered:
            species_ordered.append(sp)
    for sp in species:
        if sp not in species_ordered:
            species_ordered.append(sp)

    species = species_ordered

    abund = _scale_abund(
        {k: solar[k] for k in needed_elem}, metallicity, C_O, N_O
    )

    input_elem = list(elem_arr)
    abund_vec = np.array([abund[e] for e in input_elem])

    pre_atm = ma.build_pre_atm(
        pressure,
        temperature,
        input_elem=input_elem,
        output_species=species,
        abundances_path=abundance_file,
        cfg_file=cfg_file,
    )

    n_layers = pressure.size
    pre_atm["atom_abundances"] = np.tile(abund_vec, (n_layers, 1))

    df = ra.run_tea(pre_atm, cfg_file=cfg_file)

    avg = df.mean(axis=0)

    mixratio = {
        sp.split("_")[0]: float(avg[sp]) for sp in input_species if sp in avg
    }
    return mixratio


# ------------ -------------------------------------------------------
# -- CHEMICAL EQUILIBRIUM -- -----------------------------------------
def crbce(p, temp, C2Or=0.0, X2Hr=0.0, N2Or=0.0):
    '''
    G. ROUDIER: BURROWS AND SHARP 1998 + ANDERS & GREVESSE 1989
    '''
    solar = {
        'nH': 9.10e-1,
        'nHe': 8.87e-2,
        'nO': 7.76e-4,
        'nC': 3.29e-4,
        'nNE': 1.12e-4,
        'nN': 1.02e-4,
        'nMg': 3.49e-5,
        'nSi': 3.26e-5,
        'nFe': 2.94e-5,
        'nS': 1.68e-5,
        'nAr': 3.29e-6,
        'nAl': 2.77e-6,
        'nCa': 1.99e-6,
        'nNa': 1.87e-6,
        'nNi': 1.61e-6,
        'nCr': 4.40e-7,
        'nP': 3.39e-7,
        'nMn': 3.11e-7,
        'nCl': 1.71e-7,
        'nK': 1.23e-7,
        'nTi': 7.83e-8,
        'nCo': 7.34e-8,
        'nF': 2.75e-8,
        'nV': 9.56e-9,
        'nLi': 1.86e-9,
        'nRb': 2.31e-10,
        'nCs': 1.21e-11,
    }
    a1 = 1.106131e6
    b1 = -5.6895e4
    c1 = 62.565
    d1 = -5.81396e-4
    e1 = 2.346515e-8
    RcalpmolpK = 1.9872036  # cal/mol/K

    solCtO = solar['nC'] / solar['nO']
    solNtO = solar['nN'] / solar['nO']

    # define metal as all elements except H and He
    metal = solar.copy()
    metal['nH'] = 0.0
    metal['nHe'] = 0.0
    # sum up the metal part.  It's 10^-2.84 dex
    nXsolar = np.sum(np.array([x[1] for x in metal.items()]))

    # (C2O,N2O are limited by the prior bounds, so limits not really needed)
    C2Or = max(C2Or, -10.0)
    C2Or = min(C2Or, 10.0)
    N2Or = max(N2Or, -10.0)
    N2Or = min(N2Or, 10.0)

    Xfactor = 10.0**X2Hr
    Cfactor = 10.0**C2Or
    Nfactor = 10.0**C2Or

    # OLD linear method, with max limit at 2.84 dex
    # if Xfactor >= 1.0 / nXsolar:
    #    nHplusHeold = 1e-16
    #    nXold = 1.0
    # else:
    #    nHplusHeold = 1.0 - Xfactor * nXsolar
    #    nXold = Xfactor * nXsolar

    # NEW method defined such that X2Hr is the X-to-H ratio
    #  for both methods, nHplusHe + nX totals to 1
    nHplusHe = (1.0 - nXsolar) / (1.0 - nXsolar + Xfactor * nXsolar)
    nX = Xfactor * nXsolar / (1.0 - nXsolar + Xfactor * nXsolar)

    # breakdown nHplusHe into nH and nHe
    # nHold = nHplusHe
    # nHeold = nHplusHe * solar['nHe'] / solar['nH']
    nH = nHplusHe * solar['nH'] / (solar['nHe'] + solar['nH'])
    nH2 = nHplusHe / 2.0
    nHe = nHplusHe * solar['nHe'] / (solar['nHe'] + solar['nH'])

    # print('           nHHe-old, nHHe-new', nHplusHeold, nHplusHe)
    # print('           nH-old, nH-new', nHold, nH)
    # print('           nHe-old, nHe-new', nHeold, nHe)
    # print('           X-old, X-new', nXold, nX)

    pH2 = nH2 * p  # array
    K1 = np.exp(
        (a1 / temp + b1 + c1 * temp + d1 * temp**2 + e1 * temp**3)
        / (RcalpmolpK * temp)
    )
    AH2 = (pH2**2.0) / (2.0 * K1)
    ACpAO = nX / nXsolar / nH * solar['nO'] * (1.0 + Cfactor * solCtO)
    ACtAO = Cfactor * solCtO * (solar['nO'] ** 2) * ((nX / nXsolar / nH) ** 2)
    BCO = ACpAO + AH2 - np.sqrt((ACpAO + AH2) ** 2 - 4.0 * ACtAO)
    # <--
    # GMR: We should be prepared for T-P profile change that later
    # -->
    nCO = np.mean(BCO * pH2 / p)
    nCH4 = np.mean((2.0 * nX / nXsolar / nH * solar['nC'] - BCO) * (pH2 / p))
    nH2O = np.mean((2.0 * nX / nXsolar / nH * solar['nO'] - BCO) * (pH2 / p))

    a2 = 8.16413e5
    b2 = -2.9109e4
    c2 = 58.5878
    d2 = -7.8284e-4
    e2 = 4.729048e-8
    K2 = np.exp(
        (a2 / temp + b2 + c2 * temp + d2 * temp**2 + e2 * temp**3)
        / (RcalpmolpK * temp)
    )
    AN = nX / nXsolar * Nfactor * solNtO * solar['nO'] / nH  # solar['nN']/nH
    AH2 = (pH2**2.0) / (8.0 * K2)
    # take absolute value, just to be sure that there's never a negative value
    BN2 = AN + AH2 - np.sqrt(np.abs((AN + AH2) ** 2.0 - (AN) ** 2.0))
    BNH3 = 2.0 * (AN - BN2)
    nN2 = np.nanmean(BN2 * pH2 / p)
    nNH3 = np.nanmean(BNH3 * pH2 / p)

    nCO = np.max([nCO, 1e-16])
    nCH4 = np.max([nCH4, 1e-16])
    nH2O = np.max([nH2O, 1e-16])
    nN2 = np.max([nN2, 1e-16])
    nNH3 = np.max([nNH3, 1e-16])

    # make sure that the sum of all mixing ratios does not exceed 1
    #  ok actually it's working great. no problems here (molecules are 60-75%)
    # nMolecules = nH2O + nCH4 + nNH3 + nN2 + nCO
    # print('nSummed vs nMax',nMolecules,1 - nHplusHe)
    # print('nSummed vs nMax',nMolecules / (1 - nHplusHe))

    mixratio = {
        'H2O': np.log10(nH2O) + 6.0,
        'CH4': np.log10(nCH4) + 6.0,
        'NH3': np.log10(nNH3) + 6.0,
        'N2': np.log10(nN2) + 6.0,
        'CO': np.log10(nCO) + 6.0,
    }
    # print('mixratio', mixratio)
    return mixratio, nH2, nHe


# -------------------- -----------------------------------------------
# -- MEAN MOLECULAR WEIGHT -- ----------------------------------------
def getmmw(mixratio, protosolar=True, fH2=None, fHe=None, verbose=False):
    '''
    G. ROUDIER: Mean molecular weight estimate assuming proton mass dominated nucleus
    '''
    molsum = 0.0
    mmw = 0.0
    weights = {
        'H2': 2.0,
        'He': 4.0,
        'CH4': 16.0,
        'NH3': 17.0,
        'H2O': 18.0,
        'H2CO': 30.0,
        'TIO': 64,
        'HCN': 27.0,
        'N2': 28.0,
        'C2H2': 26.0,
        'C2H4': 28.0,
        'NO2': 46.0,
        'N2O': 44.0,
        'O3': 48.0,
        'HNO3': 63.0,
        'O2': 32.0,
        'CO': 28.0,
        'CO2': 44.0,
        'NO': 30.0,
        'OH': 17.0,
        'PH3': 34.0,
        'SO2': 64.0,
        'H2S': 34.0,
    }

    for elem in mixratio:
        molsum = molsum + 10.0 ** (mixratio[elem] - 6.0)
        mmw = mmw + 10.0 ** (mixratio[elem] - 6.0) * weights[elem]
        if verbose:
            print('molsum,mmw', molsum, mmw)
    mrH2He = 1.0 - molsum
    # Lodders 2010
    if protosolar:
        HEoH2 = 2.0 * 2.343 * 1e9 / (2.431 * 1e10)
    else:
        HEoH2 = fHe / fH2
    if verbose:
        print('fHe,fH2', fHe, fH2)
    if verbose:
        print('HEoH2', HEoH2)
    mrH2 = mrH2He / (1.0 + HEoH2)
    mrHe = HEoH2 * mrH2
    mmw = mrH2 * weights['H2'] + mrHe * weights['He'] + mmw
    if verbose:
        print('*** mmw ***', mmw)
    return mmw, mrH2, mrHe
